import ts from "typescript";
import {readFileSync} from 'fs';
import {resolve, dirname} from "path";
import { ParseModelFrom } from "./parser";
import { serializeAST } from "./serialize-ast";
import { PACKAGE_NAME } from "@src/config";

/** Load files and generate Model */
export function generateModel(tsConfigPath: string, files: string[], pretty:boolean, emitFile: (content:string)=>void):void{
	//* Parse tsConfig
	var tsP= ts.parseConfigFileTextToJson(tsConfigPath, readFileSync(tsConfigPath, 'utf-8'));
	if(tsP.error) throw new Error("Config file parse fails:" + tsP.error.messageText.toString());
	var tsP2= ts.convertCompilerOptionsFromJson(tsP.config.compilerOptions, process.cwd(), tsConfigPath);
	if(tsP2.errors?.length) throw new Error("Config file parse fails:" + tsP2.errors.map(e=> e.messageText.toString()));
	const compilerOptions: ts.CompilerOptions= tsP2.options;
	//* Create program
	const program= ts.createProgram(files, compilerOptions);
	//* check for files with "Model.from('glob-path')"
	const mappedFiles= filterAndMapFilesWithModel(files, program.getSourceFiles());
	
	//* Resolve Model for each pattern
	const ModelMap: Map<string, ts.ObjectLiteralExpression>= new Map();
	mappedFiles.patterns.forEach(function(p){
		ModelMap.set(p, serializeAST(ParseModelFrom(p, compilerOptions), ts.factory, pretty));
	});

	//* Insert in each target file
	const printer= ts.createPrinter();
	var i, len, targetFiles= mappedFiles.files;
	for(i=0, len= targetFiles.length; i<len; ++i){
		let {file, ModelVarName}= targetFiles[i];
		file= ts.transform(file, [function(ctx:ts.TransformationContext): ts.Transformer<ts.Node>{
			return _createModelInjectTransformer(ctx, file, ModelVarName);
		}]) as unknown as ts.SourceFile;
		emitFile(printer.printFile(file));
	}
	//* Export stream
	console.log('END.')

	/** Inject model */
	function _createModelInjectTransformer(ctx:ts.TransformationContext, sf: ts.SourceFile, ModelVarName: Set<string>): ts.Transformer<ts.Node>{
		const dir= dirname(sf.fileName);
		const factory= ctx.factory;
		function _visitor(node:ts.Node):ts.Node{
			if(ts.isCallExpression(node) && ts.isPropertyAccessExpression(node.expression) && ModelVarName.has(node.expression.getFirstToken()!.getText())){
				if(node.expression.name.getText() === 'from'){
					let arg= node.arguments[0].getText();
					arg= arg.slice(1, arg.length-1); // remove quotes
					arg= resolve(dir, arg); // resolve absolute path pattern
					node= factory.createCallExpression(
						factory.createIdentifier(node.expression.getFirstToken()!.getText()),
						undefined,
						[ModelMap.get(arg)!]
					);
				}
			} else {
				node= ts.visitEachChild(node, _visitor, ctx);
			}
			return node;
		}
		return _visitor;
	}
}

/** filterFilesWithModel response */
interface FilterFilesWithModelResp{
	/** Absolute Glob pattern inside: "Model.from(pattern)" */
	patterns: Set<string>
	/** Selected files (has "model.from") */
	files: {
		file: ts.SourceFile
		ModelVarName: Set<string>
	}[]
}
/** Filter files to get those with "Model.from('glob-path')" */
function filterAndMapFilesWithModel(files: string[], srcFiles: readonly ts.SourceFile[]): FilterFilesWithModelResp{
	const filesSet= new Set(files);
	var i, len, srcFile: ts.SourceFile, fileName:string, node: ts.Node;
	const queue= [];
	const foundGlobPatterns:Set<string>= new Set();
	const results: FilterFilesWithModelResp= {
		patterns: new Set(),
		files: []
	};
	for(i=0, len= srcFiles.length; i<len; i++){
		//* Parse each file
		srcFile= srcFiles[i];
		fileName= srcFile.fileName;
		if(!filesSet.has(fileName))
			continue;
		queue.length= 0;
		queue.push(srcFile);
		const ModelVarName:Set<string>= new Set();
		foundGlobPatterns.clear();
		let j=0;
		while(j<queue.length){
			node= queue[j++];
			if(ts.isImportDeclaration(node) && node.moduleSpecifier.getText() === PACKAGE_NAME){
				// Load names used for "Model"
				node.importClause?.namedBindings?.forEachChild(function(n){
					if(ts.isImportSpecifier(n) && (n.propertyName ?? n.name).getText() === 'Model'){
						ModelVarName.add(n.name.getText());
					}
				});
			} else if(ts.isCallExpression(node) && ts.isPropertyAccessExpression(node.expression) && ModelVarName.has(node.expression.getFirstToken()!.getText())){
				let arg;
				if(node.expression.name.getText()==='from'){
					if(node.arguments.length===1 && (arg= node.arguments[0]) && ts.isStringLiteral(arg)){
						foundGlobPatterns.add(arg.getText());
					} else {
						throw new Error(`Expect static string as argument to "Model::from" at ${fileName}:${node.getStart()}. Code: ${node.getText()}`);
					}
				}
			} else if(node.getChildCount()){
				queue.push(...node.getChildren());
			}
		}
		// found
		if(foundGlobPatterns.size){
			results.files.push({
				file: srcFile,
				ModelVarName: ModelVarName
			});
			let dir= dirname(fileName);
			foundGlobPatterns.forEach(v=>{
				results.patterns.add(resolve(dir, v.slice(1, v.length-1)));
			});
		}
	}
	return results;
}